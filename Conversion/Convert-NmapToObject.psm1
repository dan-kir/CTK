function Convert-NmapToObject() 
{
    <#
 
    .SYNOPSIS
    Converts a list of Nmap XML files into a custom object with details about each scanned host.

    .DESCRIPTION
    This function reads in a list of Nmap XML files and processes each one. It extracts data about each host in the file and stores it in a custom object. The custom object includes the following details: HostName, FQDN, Status, IPv4, IPv6, MAC, Ports, Services, OS, Script, timestamp, StartedAt, FinishedAt. The function returns a list of these custom objects, one for each host in each Nmap XML file.

    .PARAMETER Path
    A list of file paths to Nmap XML files.

    .PARAMETER OutputDelimiter
    Specifies the delimiter to use when concatenating multiple values for certain fields in the custom object. The default is a newline character.

    .NOTES
    This function requires that the Nmap XML files have a specific format. It may not work correctly with XML files that have been modified or that were not generated by Nmap.

    #>
	param ($Path, [String] $OutputDelimiter = "`n")
	$results = @()
	ForEach ($file in $Path) 
    {
		Write-Verbose -Message ("[" + (get-date).ToLongTimeString() + "] Starting $file" )
        $StartTime = get-date  

		$xmldoc = new-object System.XML.XMLdocument
		$xmldoc.Load($file)
		
		# Process each of the <host> nodes from the nmap report.
		$i = 0  #Counter for <host> nodes processed.

        foreach ($hostnode in $xmldoc.nmaprun.host) 
        { 
            # Init some variables, with $entry being the custom object for each <host>. 
	        $service = " " #service needs to be a single space.
	        # $entry = ($entry = " " | select-object HostName, FQDN, Status, IPv4, IPv6, MAC, Ports, Services, OS, Script, timestamp, StartedAt, FinishedAt) 
            $entry = @{
                HostName = ""
                FQDN = ""
                Status = ""
                IPv4 = ""
                IPv6 = ""
                MAC = ""
                Ports = ""
                Services = ""
                OS = ""
                Script = ""
                StartedAt = ""
                FinishedAt = ""
                OpenPorts = @()
            }
			# Extract state element of status:
			if ($null -ne $hostnode.Status -and $hostnode.Status.length -ne 0) { $entry.Status = $hostnode.status.state.Trim() }  
			if ($entry.Status.length -lt 2) { $entry.Status = "<no-status>" }

			# Extract computer names provided by user or through PTR record, but avoid duplicates and allow multiple names.
            # Note that $hostnode.hostnames can be empty, and the formatting of one versus multiple names is different.
            # The crazy foreach-ing here is to deal with backwards compatibility issues...
            $tempFQDN = $tempHostName = ""
			ForEach ($hostname in $hostnode.hostnames)
            {
                ForEach ($hname in $hostname.hostname)
                {
                    ForEach ($namer in $hname.name)
                    {
                        if ($null -ne $namer -and $namer.length -ne 0 -and $namer.IndexOf(".") -ne -1) 
                        {
                            #Only append to temp variable if it would be unique.
                            if($tempFQDN.IndexOf($namer.tolower()) -eq -1)
                            { $tempFQDN = $tempFQDN + " " + $namer.tolower() }
                        }
                        elseif ($null -ne $namer -and $namer.length -ne 0)
                        {
                            #Only append to temp variable if it would be unique.
                            if($tempHostName.IndexOf($namer.tolower()) -eq -1)
                            { $tempHostName = $tempHostName + " " + $namer.tolower() } 
                        }
                    }
                }
            }

            $tempFQDN = $tempFQDN.Trim()
            $tempHostName = $tempHostName.Trim()

            if ($tempHostName.Length -eq 0 -and $tempFQDN.Length -eq 0) { $tempHostName = "<no-hostname>" } 

            #Extract hostname from the first (and only the first) FQDN, if FQDN present.
            if ($tempFQDN.Length -ne 0 -and $tempHostName.Length -eq 0) 
            { $tempHostName = $tempFQDN.Substring(0,$tempFQDN.IndexOf("."))  } 

            if ($tempFQDN.Length -eq 0) { $tempFQDN = "<no-fullname>" }

            $entry.FQDN = $tempFQDN
            $entry.HostName = $tempHostName  #This can be different than FQDN because PTR might not equal user-supplied hostname.
            


			# Process each of the <address> nodes, extracting by type.
			ForEach ($addr in $hostnode.address)
            {
				if ($addr.addrtype -eq "ipv4") { $entry.IPv4 += $addr.addr + " "}
				if ($addr.addrtype -eq "ipv6") { $entry.IPv6 += $addr.addr + " "}
				if ($addr.addrtype -eq "mac")  { $entry.MAC  += $addr.addr + " "}
			}        
			if ($null -eq $entry.IPv4) { $entry.IPv4 = "<no-ipv4>" } else { $entry.IPv4 = $entry.IPv4.Trim()}
			if ($null -eq $entry.IPv6) { $entry.IPv6 = "<no-ipv6>" } else { $entry.IPv6 = $entry.IPv6.Trim()}
			if ($null -eq $entry.MAC) { $entry.MAC  = "<no-mac>"  } else { $entry.MAC  = $entry.MAC.Trim() }


			# Process all ports from <ports><port>, and note that <port> does not contain an array if it only has one item in it.
            # This could be parsed out into separate properties, but that would be overkill.  We still want to be able to use
            # simple regex patterns to do our filtering afterwards, and it's helpful to have the output look similar to
            # the console output of nmap by itself for easier first-time comprehension.  
			if ($null -eq $hostnode.ports.port) { $entry.Ports = "<no-ports>" ; $entry.Services = "<no-services>" } 
			else 
			{
				ForEach ($porto in $hostnode.ports.port)
                {
					if ($null -eq $porto.service.name) { $service = "unknown" } else { $service = $porto.service.name } 
					$entry.Ports += $porto.state.state + ":" + $porto.protocol + ":" + $porto.portid + ":" + $service + $OutputDelimiter 
                    # add the open ports to the openports array (for kibana analytics)
                    $entry.OpenPorts += $porto.portid
                    # Build Services property. What a mess...but exclude non-open/non-open|filtered ports and blank service info, and exclude servicefp too for the sake of tidiness.
                    if ($porto.state.state -like "open*" -and ($porto.service.tunnel.length -gt 2 -or $porto.service.product.length -gt 2 -or $porto.service.proto.length -gt 2)) { $entry.Services += $porto.protocol + ":" + $porto.portid + ":" + $service + ":" + ($porto.service.product + " " + $porto.service.version + " " + $porto.service.tunnel + " " + $porto.service.proto + " " + $porto.service.rpcnum).Trim() + " <" + ([Int] $porto.service.conf * 10) + "%-confidence>$OutputDelimiter" }
				}
				$entry.Ports = $entry.Ports.Trim()
                if ($null -eq $entry.Services) { $entry.Services = "<no-services>" } else { $entry.Services = $entry.Services.Trim() }
                if ($null -ne $entry.Services) { $entry.Services = $entry.Services.Trim() } 
			}


			# Extract fingerprinted OS type and percent of accuracy.
			ForEach ($osm in $hostnode.os.osmatch) {$entry.OS += $osm.name + " <" + ([String] $osm.accuracy) + "%-accuracy>$OutputDelimiter"} 
            ForEach ($osc in $hostnode.os.osclass) {$entry.OS += $osc.type + " " + $osc.vendor + " " + $osc.osfamily + " " + $osc.osgen + " <" + ([String] $osc.accuracy) + "%-accuracy>$OutputDelimiter"}  
            if ($null -ne $entry.OS -and $entry.OS.length -gt 0)
            {
               $entry.OS = $entry.OS.Replace("  "," ")
               $entry.OS = $entry.OS.Replace("<%-accuracy>","") #Sometimes no osmatch.
			   $entry.OS = $entry.OS.Trim()
            }
			if ($entry.OS.length -lt 16) { $entry.OS = "<no-os>" }

            
            # Extract script output, first for port scripts, then for host scripts.
            ForEach ($pp in $hostnode.ports.port)
            {
                if ($null -ne $pp.script) { 
                    $entry.Script += "<PortScript id=""" + $pp.script.id + """>$OutputDelimiter" + ($pp.script.output -replace "`n","$OutputDelimiter") + "$OutputDelimiter</PortScript> $OutputDelimiter $OutputDelimiter" 
                }
            } 
            
            if ($null -ne $hostnode.hostscript) {
                ForEach ($scr in $hostnode.hostscript.script)
                {
                    $entry.Script += '<HostScript id="' + $scr.id + '">' + $OutputDelimiter + ($scr.output.replace("`n","$OutputDelimiter")) + "$OutputDelimiter</HostScript> $OutputDelimiter $OutputDelimiter" 
                }
            }
            
            if ($null -eq $entry.Script) { $entry.Script = "<no-script>" } 
    
            #add some metadata
            $format = "ddd MMM dd HH:mm:ss yyyy"
            $entry.StartedAt = (([datetime]::ParseExact($xmldoc.nmaprun.startstr, $format, $null)).ToString("o")+(Get-Date -format "zzz"))
            # $entry.timestamp = (([datetime]::ParseExact($xmldoc.nmaprun.startstr, $format, $null)).ToString("o")+(Get-Date -format "zzz"))
            $entry.FinishedAt = (([datetime]::ParseExact($xmldoc.nmaprun.runstats.finished.timestr, $format, $null)).ToString("o")+(Get-Date -format "zzz"))
			# Emit custom object from script.
			$i++  #Progress counter...
            $results += $entry
		}        
		Write-Verbose -Message ( "[" + (get-date).ToLongTimeString() + "] Finished $file, processed $i entries." ) 
        Write-Verbose -Message ('Total Run Time: ' + ( [MATH]::Round( ((Get-date) - $StartTime).TotalSeconds, 3 )) + ' seconds')
        Write-Verbose -Message ('Entries/Second: ' + ( [MATH]::Round( ($i / $((Get-date) - $StartTime).TotalSeconds), 3 ) ) ) 
	}
    return $results
}
Export-ModuleMember Convert-NmapToObject

